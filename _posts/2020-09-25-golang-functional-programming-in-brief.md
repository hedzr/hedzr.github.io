---
layout: single
title: 'Golang å‡½æ•°å¼ç¼–ç¨‹ç®€è¿°'
date: 2020-09-25 22:55:11 +0800
last_modified_at: 2020-09-25 22:55:11 +0800
Author: hedzr
tags: [functional programming, fp, golang]
categories: golang fp
comments: true
toc: true
header:
  overlay_image: /assets/images/unsplash-image-10.jpg
  overlay_filter: rgba(128, 128, 0, 0.3)
excerpt: >-
  Golang Functional Programming in brief ...

#  caption: "Photo credit: [**Unsplash**](https://unsplash.com)"
#  actions:
#    - label: "More Info"
#      url: "https://unsplash.com"
---







## Golang Functional Programming In Brief



### å…ˆåä¸€å

ä¸€èˆ¬è€Œè¨€ï¼ŒGolang çš„ Functional ç¼–ç¨‹éƒ½ä¼šå‘ˆç°å‡ºæ¶å½¢ã€‚è¡¨é¢ä¸Šçœ‹ï¼Œæ¶å½¢æ˜¯å› ä¸º Golang ç¼ºå°‘ä¸€äº›å¿…è¦çš„è¯­æ³•ç³–ï¼›æœ¬è´¨ä¸Šè¯´ï¼Œæ¶å½¢æºäºå®ƒæ²¡æœ‰é«˜çº§æŠ½è±¡èƒ½åŠ›ï¼Œæ­£å¦‚æ³›å‹çš„ç¼ºå¤±ã€‚

#### æ¶å½¢

ä¸‘åœ¨ä½•å¤„ï¼Ÿè¿™é‡Œæœ‰ä¸ªä¾‹å­ï¼š

```go
func main() {
	var list = []string{"Orange", "Apple", "Banana", "Grape"}
	// we are passing the array and a function as arguments to mapForEach method.
	var out = mapForEach(list, func(it string) int {
		return len(it)
	})
	fmt.Println(out) // [6, 5, 6, 5]
}

// The higher-order-function takes an array and a function as arguments
func mapForEach(arr []string, fn func(it string) int) []int {
	var newArray = []int{}
	for _, it := range arr {
		// We are executing the method passed
		newArray = append(newArray, fn(it))
	}
	return newArray
}
```

å¾ˆå¥½ï¼Œæ­¤åŒ…è£…çœ‹èµ·æ¥ä¸é”™ï¼Œæ˜¯ä¸æ˜¯ï¼Ÿfpå½¢æ€çœ‹èµ·æ¥çœ‹ç€ä¹Ÿæ¯”è¾ƒèˆ’æœã€‚æˆ‘æƒ³â€¦â€¦å—¯ï¼Œæˆ‘æƒ³åŒ…è£…ä¸€ä¸‹ï¼Œä»¤å…¶é€šç”¨åŒ–ï¼Œç»™åˆ«äººç”¨ã€‚äºæ˜¯å°±ç³Ÿäº†ï¼Œæ”¯æŒint64éœ€è¦è¿™æ ·ï¼š

```go
func mapInt64ForEach(arr []int64, fn func(it int64) int) []int {
	var newArray = []int{}
	for _, it := range arr {
		// We are executing the method passed
		newArray = append(newArray, fn(it))
	}
	return newArray
}
```

è¿™æ‰åˆšåˆšå¼€å§‹ï¼Œä½ å¼€å§‹ä¸º boolï¼Œuint64ï¼Œâ€¦â€¦å†™å‡º n ä¸ªç‰ˆæœ¬ï¼Œè®°ä½ï¼Œå‡½æ•°åä¹Ÿè¦æ”¹ã€‚



#### å¯¹ç…§ï¼šC++æ¨¡æ¿å®ç°

æ‰€ä»¥æˆ‘ä¼šè¯´ï¼Œgolang çš„é«˜é˜¶å‡½æ•°ï¼Œfunctionalï¼Œå®é™…ä¸ŠçœŸçš„ä¼šé¡ºç†æˆç« åœ°æ¶å½¢ã€‚

å¤©çŸ¥é“ï¼Œç°åœ¨æˆ‘å¤šæ•°æƒ…å†µä¸‹éƒ½ä¼šé‡‡ç”¨ golang è¿›è¡Œæ¶æ„è®¾è®¡ï¼Œç„¶è€Œæˆ‘å¿ƒé‡Œä¸€ç›´æœ‰ä¸€ç§éš¾ä»¥è¨€è¯´çš„å¤±æœ›ã€‚å¦‚æœåœ¨ C++11ï¼š

```c++
class Print {
public:
	void operator()(int elem) const {
		std::cout << elem << " ";
	}
};

func a(){
	std::vector<int> vect;
	for (int i=1; i<10; ++i) {
		vect.push_back(i);
	}

	Print print_it;
	std::for_each (vect.begin(), vect.end(), print_it);
	std::cout << std::endl;
}
```

ä¸ºäº†èŠ‚çº¦å­—èŠ‚ï¼Œè¿™é‡Œå€Ÿç”¨ stdlib çš„ for_each è€Œä¸æ˜¯è‡ªè¡Œå®ç°ä¸€ä»½ï¼Œä½† foreach çš„å®ç°å…¶å®ä¹ŸçœŸå¿ƒç®€å•ã€‚

é‡ç‚¹åœ¨äºï¼Œæˆ‘ç°åœ¨è¦æ“ä½œ string äº†ï¼Œåªéœ€è¦é‡å†™ä¸€ä»½ Print å°±å¯ä»¥äº†ï¼Œæˆ‘å¹¶ä¸éœ€è¦åš n ä»½ for_each å®ç°ã€‚å¦‚æœæœ‰å¿…è¦ï¼Œæˆ‘å¯ä»¥å®ç°ä¸€ä»½æ³›å‹çš„ Print<T> æ¨¡æ¿ç±»ï¼Œäºæ˜¯ä»€ä¹ˆéƒ½ä¸å¿…é‡æ–°å®ç°å‰¯æœ¬ï¼Œç›´æ¥ä½¿ç”¨å°±å¯ä»¥äº†ã€‚



#### æ”¶ç»“

è¿˜æ²¡æœ‰å¼€å§‹ç ”ç©¶ Golang Functional Programming çš„ç¾ä¸½çš„åœ°æ–¹ï¼Œåè€Œå…ˆè´¬æŸäº†ä¸€ç•ªï¼ŒçœŸæ˜¯æƒ…éå¾—å·²å•Šï¼



å¥½ï¼Œç°åœ¨æ¥è®² functional çš„å¥½çš„ç”¨æ³•ã€‚

è™½ç„¶ functional å¹¶ä¸æ˜“äºæ³›å‹å¤ç”¨ï¼Œä½†åœ¨å…·ä½“ç±»å‹ï¼Œåˆæˆ–è€…æ˜¯é€šè¿‡ interface æŠ½è±¡åçš„é—´æ¥æ³›å‹æ¨¡å‹ä¸­ï¼Œå®ƒæ˜¯æ”¹å–„ç¨‹åºç»“æ„ã€å¤–è§‚ã€å†…æ¶µã€è´¨é‡çš„æœ€ä½³æ‰‹æ®µã€‚

æ‰€ä»¥ä½ ä¼šçœ‹åˆ°ï¼Œåœ¨æˆç†Ÿçš„ç±»åº“ä¸­ï¼Œæ— è®ºæ˜¯æ ‡å‡†åº“è¿˜æ˜¯ç¬¬ä¸‰æ–¹åº“ï¼Œfunctional æ¨¡å¼è¢«å¹¿æ³›åœ°é‡‡ç”¨ã€‚

æ‰€ä»¥ï¼Œä¸‹é¢ä¼šå¯¹è¿™äº›åº”ç”¨ä½œä¸€ç•ªå½’çº³å’Œå±•ç¤ºï¼Œç›®çš„åœ¨äºæä¾›ä¸€ç³»åˆ—æœ€ä½³å®è·µçš„é™ˆåˆ—å¹¶å¸Œæœ›ç±æ­¤æœ‰åŠ©äºæé«˜ä½ çš„å…·ä½“ç¼–ç èƒ½åŠ›ã€‚





### ä»€ä¹ˆæ˜¯ Functional Programming

é¦–å…ˆæˆ‘ä»¬éœ€è¦ç ”ç©¶ä¸€ä¸‹ä»€ä¹ˆæ˜¯é«˜é˜¶å‡½æ•°ç¼–ç¨‹ï¼Ÿæ‰€è°“çš„ Functional Programmingï¼Œä¸€èˆ¬è¢«è¯‘ä½œå‡½æ•°å¼ç¼–ç¨‹ï¼ˆä»¥ Î»æ¼”ç®—[^3] ä¸ºæ ¹åŸºï¼‰ã€‚

å‡½æ•°å¼ç¼–ç¨‹ï¼Œæ˜¯æŒ‡å¿½ç•¥ï¼ˆé€šå¸¸æ˜¯ä¸å…è®¸ï¼‰å¯å˜æ•°æ®ï¼ˆä»¥é¿å…å®ƒå¤„å¯æ”¹å˜çš„æ•°æ®å¼•å‘çš„è¾¹é™…æ•ˆåº”ï¼‰ï¼Œå¿½ç•¥ç¨‹åºæ‰§è¡ŒçŠ¶æ€ï¼ˆä¸å…è®¸éšå¼çš„ã€éšè—çš„ã€ä¸å¯è§çš„çŠ¶æ€ï¼‰ï¼Œé€šè¿‡å‡½æ•°ä½œä¸ºå…¥å‚ï¼Œå‡½æ•°ä½œä¸ºè¿”å›å€¼çš„æ–¹å¼è¿›è¡Œè®¡ç®—ï¼Œé€šè¿‡ä¸æ–­çš„æ¨è¿›ï¼ˆè¿­ä»£ã€é€’å½’ï¼‰è¿™ç§è®¡ç®—ï¼Œä»è€Œä»è¾“å…¥å¾—åˆ°è¾“å‡ºçš„ç¼–ç¨‹èŒƒå¼ã€‚åœ¨å‡½æ•°å¼ç¼–ç¨‹èŒƒå¼ä¸­ï¼Œæ²¡æœ‰è¿‡ç¨‹å¼ç¼–ç¨‹æ‰€å¸¸è§çš„æ¦‚å¿µï¼šè¯­å¥ï¼Œè¿‡ç¨‹æ§åˆ¶ï¼ˆæ¡ä»¶ï¼Œå¾ªç¯ç­‰ç­‰ï¼‰ã€‚æ­¤å¤–ï¼Œåœ¨å‡½æ•°å¼ç¼–ç¨‹èŒƒå¼ä¸­ï¼Œå…·æœ‰å¼•ç”¨é€æ˜ï¼ˆReferential Transparencyï¼‰çš„ç‰¹æ€§ï¼Œæ­¤æ¦‚å¿µçš„å«ä¹‰æ˜¯å‡½æ•°çš„è¿è¡Œä»…ä»…å’Œå…¥å‚æœ‰å…³ï¼Œå…¥å‚ç›¸åŒåˆ™å‡ºå‚å¿…ç„¶æ€»æ˜¯ç›¸åŒï¼Œå‡½æ•°æœ¬èº«ï¼ˆè¢«è§†ä½œ*f(x)*ï¼‰æ‰€å®Œæˆçš„å˜æ¢æ˜¯ç¡®å®šçš„ã€‚

> é¡ºä¾¿ä¸€æï¼ŒæŸ¯é‡ŒåŒ–[^4] æ˜¯å‡½æ•°å¼ç¼–ç¨‹ä¸­ç›¸å½“é‡è¦çš„ä¸€ä¸ªç†è®ºå’ŒæŠ€æœ¯ã€‚å®Œå…¨æŠ›å¼ƒè¿‡ç¨‹å¼ç¼–ç¨‹çš„ ifã€thenã€while ä¹‹ç±»çš„ä¸œè¥¿ï¼Œå®Œå…¨çš„å‡½æ•°è¿­ä»£ï¼Œä¸€èˆ¬æ˜¯çº¯å‡½æ•°å¼æ”¯æŒè€…æœ€ä¸ºå–œçˆ±çš„ï¼Œè€Œè¯¸å¦‚ `Start(...).Then(...).Then(...).Else(...).Finally(...).Stop()` è¿™ç±»é£æ ¼å¾€å¾€ä¼šè¢«è§†ä¸ºå¼‚æ•™å¾’ã€‚
>
> è¿™ç¡®å®å¾ˆæœ‰æ„æ€ã€‚åŸæ•™æ—¨ä¸»ä¹‰ï¼ˆæŒ‰ï¼šéæŒ‡è¯¥æœ¯è¯­çš„å®—æ•™æ€§åŸæ„ï¼Œä»…ç”¨äºåœ¨æ­¤å¤„å¼•ç”³ä»¥æŒ‡ä»£ Pure å…šï¼‰åœ¨ä»»ä½•åœ°æ–¹éƒ½æ˜¯ç¡®å®šåŠå­˜åœ¨çš„ã€‚

#### è¡¨å¾

æ€»ç»“ä¸€ä¸‹ï¼Œå‡½æ•°å¼ç¼–ç¨‹å…·æœ‰ä»¥ä¸‹çš„è¡¨å¾ï¼š

1. **No Data mutations** æ²¡æœ‰æ•°æ®æ˜“å˜æ€§
2. **No implicit state** æ²¡æœ‰éšå¼çŠ¶æ€
3. **No side effects** æ²¡æœ‰è¾¹é™…æ•ˆåº”ï¼ˆæ²¡æœ‰å‰¯ä½œç”¨ï¼‰
4. **Pure functions only** åªæœ‰çº¯ç²¹çš„å‡½æ•°ï¼Œæ²¡æœ‰è¿‡ç¨‹æ§åˆ¶æˆ–è€…è¯­å¥
5. First-class function å¤´ç­‰å‡½æ•°èº«ä»½
6. First-class citizen å‡½æ•°å…·æœ‰ä¸€ç­‰å…¬æ°‘èº«ä»½
7. [Higher-order functions](https://en.wikipedia.org/wiki/Higher-order_function) é«˜é˜¶å‡½æ•°ï¼Œå¯ä»¥å‡ºç°åœ¨ä»»ä½•åœ°æ–¹
8. [Closures](https://en.wikipedia.org/wiki/Closure_(computer_programming)) é—­åŒ… - å…·æœ‰ä¸Šçº§ç¯å¢ƒæ•ä¿˜èƒ½åŠ›çš„å‡½æ•°å®ä¾‹
9. [Currying](https://en.wikipedia.org/wiki/Currying) æŸ¯é‡ŒåŒ–æ¼”ç®—[^4] - è§„çº¦å¤šä¸ªå…¥å‚åˆ°å•ä¸ªï¼Œç­‰ç­‰
10. [Recursion](https://en.wikipedia.org/wiki/Recursion_(computer_science)) é€’å½’è¿ç®— - å‡½æ•°åµŒå¥—è¿­ä»£ä»¥æ±‚å€¼ï¼Œæ²¡æœ‰è¿‡ç¨‹æ§åˆ¶çš„æ¦‚å¿µ
11. [Lazy evaluations](https://en.wikipedia.org/wiki/Lazy_evaluation) / [Evaluation strategy](https://en.wikipedia.org/wiki/Evaluation_strategy) æƒ°æ€§æ±‚å€¼ - å»¶è¿Ÿè¢«æ•ä¿˜å˜é‡çš„æ±‚å€¼åˆ°ä½¿ç”¨æ—¶
12. [Referential transparency](https://en.wikipedia.org/wiki/Referential_transparency) å¼•ç”¨é€æ˜æ€§ - å¯¹äºç›¸åŒçš„è¾“å…¥ï¼Œè¡¨è¾¾å¼çš„å€¼å¿…é¡»ç›¸åŒï¼Œå¹¶ä¸”å…¶è¯„ä¼°å¿…é¡»æ²¡æœ‰å‰¯ä½œç”¨

ç”±äºé‡å¿ƒä¸åœ¨é«˜çº§ FP ç¼–ç¨‹å’Œç›¸å…³å­¦ä¹ ï¼Œå› æ­¤æ— æ³•æ·±å…¥è®¨è®ºçº¯ç§çš„ FP æŸ¯é‡ŒåŒ–å˜æ¢ï¼Œè¿™æ˜¯ä¸ªä¼ ç»Ÿ C ç¨‹åºå‘˜è¾ƒéš¾è½¬å¼¯çš„ä¸œè¥¿ã€‚



#### Golang ä¸­çš„å‡½æ•°å¼ç¼–ç¨‹ï¼šé«˜é˜¶å‡½æ•°

åœ¨ Golang ä¸­ï¼Œå‡½æ•°å¼ç¼–ç¨‹è¿™ä¸ªæ¦‚å¿µå·²ç»è¢«é‡æ–°åŒ…è£…å’Œé˜é‡Šè¿‡äº†ï¼Œè¯¸å¦‚ä¸€åˆ‡éƒ½æ˜¯å‡½æ•°ï¼Œå‡½æ•°æ˜¯å€¼ï¼Œç­‰ç­‰ã€‚æ‰€ä»¥æœ¬æ–‡ä¸­å¯èƒ½ä¼šé¿å…å‡½æ•°å¼ç¼–ç¨‹çš„ææ³•ï¼Œå¾€å¾€ä¼šä»¥é«˜é˜¶å‡½æ•°ç¼–ç¨‹çš„ææ³•ä»£æ›¿ä¹‹ã€‚

éœ€è¦å¼ºè°ƒçš„æ˜¯ï¼Œå‡½æ•°å¼ç¼–ç¨‹å¹¶éä»…ä»…æ˜¯é«˜é˜¶å‡½æ•°ç¼–ç¨‹ï¼Œé«˜é˜¶å‡½æ•°ç¼–ç¨‹ä¹Ÿä¸èƒ½åŒ…å®¹å‡½æ•°å¼ç¼–ç¨‹ï¼Œè¿™æ˜¯ä¸¤ç§ä¸åŒçš„æ¦‚å¿µï¼Œåªæ˜¯åœ¨è¡¨ç°å½¢å¼ä¸Šå½¼æ­¤ä¹‹é—´æœ‰æ‰€äº¤é›†ã€‚è€Œå¯¹äº Golang æ¥è¯´ï¼Œæ—¢æ²¡æœ‰çœŸæ­£çš„çº¯ç²¹çš„å‡½æ•°å¼ç¼–ç¨‹ï¼Œå½“ç„¶å…¶å® Golang ä¹Ÿæ²¡æœ‰çº¯ç²¹çš„é¢å‘å¯¹è±¡ç¼–ç¨‹ï¼ŒGolang å¯¹è¿™ä¸¤è€…éƒ½é‡‡ç”¨ä¸åŒçš„ã€ç•¥æœ‰æç«¯çš„æ‰‹æ³•è¿›è¡Œäº†æ”¹å¤´æ¢é¢ã€ä¹ŸåŒ…å«ä¸€äº›ä¸æ—¶ä¿±é™çš„å…ˆè¿›æ€§ç†è®ºçš„èåˆã€‚å½“ç„¶ï¼Œåœ¨å¤§å¤šæ•°åœºæ™¯ä¸Šï¼Œæˆ‘ä»¬è¿˜æ˜¯è®¤åŒ Golang é‡‡ç”¨è‡ªå·±çš„å“²å­¦æ”¯æŒè¿™æ ·çš„å¤šèŒƒå¼ç¼–ç¨‹ã€‚



åœ¨ Golang ä¸­ï¼Œé«˜é˜¶å‡½æ•°å¾ˆå¤šæ—¶å€™æ˜¯ä¸ºäº†å®ç°æŸç§ç®—æ³•çš„å…³é”®ç²˜åˆå‰‚ã€‚

ä¾‹å¦‚ï¼Œ

1. åŸºæœ¬çš„é—­åŒ…ç»“æ„
2. é€’å½’
3. å‡½å­/è¿ç®—å­
4. æƒ°æ€§è®¡ç®—
5. å¯å˜å‚æ•°ï¼šFunctional Options
6. 





### åŸºæœ¬çš„é—­åŒ…ï¼ˆClosureï¼‰ç»“æ„

åœ¨å‡½æ•°ã€é«˜é˜¶å‡½æ•°èº«å±ä¸€é˜¶å…¬æ°‘çš„ç¼–ç¨‹è¯­è¨€ä¸­ï¼Œä½ å½“ç„¶å¯ä»¥å°†å‡½æ•°èµ‹å€¼ä¸ºä¸€ä¸ªå˜é‡ã€å¤åˆ¶ç»™ä¸€ä¸ªæˆå‘˜ï¼Œä½œä¸ºå¦ä¸€å‡½æ•°çš„å‚æ•°ï¼ˆæˆ–ä¹‹ä¸€ï¼‰è¿›è¡Œä¼ å‚ï¼Œä½œä¸ºå¦ä¸€å‡½æ•°çš„è¿”å›å€¼ï¼ˆæˆ–ä¹‹ä¸€ï¼‰ã€‚

Golang å…·å¤‡ä¸Šè¿°æ”¯æŒã€‚

ç„¶è€Œï¼ŒGolang æ²¡æœ‰åŒ¿åå‡½æ•°å¤–æ‰©æˆ–ç¼©å‡çš„è¯­æ³•ç³–ï¼Œå®é™…ä¸Šï¼ŒGolang æ²¡æœ‰å¤§å¤šæ•°çš„è¯­æ³•ç³–ï¼Œè¿™æ˜¯å®ƒçš„è®¾è®¡å“²å­¦æ‰€å†³å®šçš„ã€‚æ‰€ä»¥ä½ å¿…é¡»é‡‡ç”¨æœ‰ç‚¹å†—é•¿çš„ä»£ç ä¹¦å†™ï¼Œè€Œæ— æ³•è®©è¯­æ³•æ˜¾å¾—ç®€æ´ã€‚åœ¨è¿™ä¸€ç‚¹ä¸Šï¼ŒC++ ä½¿ç”¨ operator() çš„æ–¹å¼èƒ½å¤Ÿç¼©å†™ï¼Œé‡‡ç”¨ [] æ•ä¿˜è¯­æ³•èƒ½å¤Ÿç®€å†™é—­åŒ…å‡½æ•°ï¼ŒJava 8 ä»¥ååœ¨åŒ¿åé—­åŒ…çš„ç®€åŒ–è¯­æ³•ä¸Šè¡Œè¿›çš„å¾ˆå‰å®³ï¼Œä½†è¿˜æ¯”ä¸ä¸Š Kotlinï¼ŒKotlin åˆ™æ›´è¿›ä¸€æ­¥å…è®¸å‡½æ•°è°ƒç”¨çš„æœ€åä¸€ä¸ªé—­åŒ…è¢«å¤–æ‰©åˆ°è°ƒç”¨è¯­æ³•ä¹‹åå¹¶ä»¥è¯­å¥å—çš„å½¢å¼è€Œå­˜åœ¨ï¼š

```kotlin
fun invoker(p1 string, fn fun(it int)) {
  // ...
}

invoker("ok") { /* it int */ ->
  // ...
}
```

ä½†åœ¨ Golang ä¸­ï¼Œä½ éœ€è¦å®Œæ•´åœ°ç¼–å†™é«˜é˜¶å‡½æ•°çš„åŸå‹ï¼Œå“ªæ€•ä½ å¯¹å…¶ä½œäº† type å®šä¹‰ä¹Ÿæ²¡ç”¨ï¼š

```go
type Handler func (a int)

func xc(pa int, handler Handler) {
  handler(pa)
}

func Test1(){
  xc(1, func(a int){ // <- è€è€å®å®åœ°å†å†™ä¸€éåŸå‹å§
    print (a)
  })
}
```

å€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œä¸€æ—¦ Handler çš„åŸå‹å‘ç”Ÿå˜åŒ–ï¼Œåº“ä½œè€…å’Œåº“ä½¿ç”¨è€…éƒ½ä¼šå¾ˆç—›è‹¦åœ°åˆ°å¤„æŸ¥æ‰¾å’Œä¿®æ”¹ã€‚

å¯¹çš„ï¼Œä½ å°†åœ¨è¿™é‡Œå­¦åˆ°ä¸€ä¸ªç¼–ç¨‹çš„é‡è¦åŸåˆ™ï¼Œæ¥å£è®¾è®¡å¿…é¡»è€ƒè™‘ç¨³å›ºæ€§ã€‚åªè¦æ¥å£ç¨³å›ºï¼Œå½“ç„¶ä¸ä¼šæœ‰ Handler çš„åŸå‹éœ€è¦è°ƒæ•´çš„å¯èƒ½æ€§ï¼Œå¯¹ä¸å¯¹ï¼Ÿå‘µå‘µã€‚

åç³Ÿå¹¶ä¸æ˜¯æˆ‘çš„çˆ±å¥½ï¼Œæ‰€ä»¥ç‚¹åˆ°ä¸ºæ­¢ã€‚





### è¿ç®—å­ Functor

ç®—å­é€šå¸¸æ˜¯ä¸€ä¸ªç®€å•å‡½æ•°ï¼ˆä½†ä¹Ÿæœªå¿…å¦‚æ­¤ï¼‰ï¼Œæ€»æ§éƒ¨åˆ†é€šè¿‡æ›¿æ¢ä¸åŒç®—å­æ¥è¾¾åˆ°æ›¿æ¢ä¸šåŠ¡é€»è¾‘çš„å®é™…å®ç°ç®—æ³•ï¼š

```go
func add(a, b int) int { return a+b }
func sub(a, b int) int { return a-b }

var operators map[string]func(a, b int) int

func init(){
  operators = map[string]func(a, b int) int {
    "+": add,
    "-": sub,
  }
}

func calculator(a, b int, op string) int {
  if fn, ok := operators[op]; op && fn!=nil{
    return fn(a, b)
  }
  return 0
}
```



### é€’å½’ Recursion

æ–æ³¢æ‹‰å¥‘ï¼Œé˜¶ä¹˜ï¼ŒHanoi å¡”ï¼Œåˆ†å½¢ç­‰æ˜¯å…¸å‹çš„é€’å½’é—®é¢˜ã€‚

åœ¨æ”¯æŒé€’å½’çš„ç¼–ç¨‹è¯­è¨€ä¸­ï¼Œæ€ä¹ˆè¿ç”¨é€’å½’å¾€å¾€æ˜¯ä¸€ä¸ªè¾ƒéš¾çš„çŸ¥è¯†ç‚¹ã€‚ä¸ªäººçš„ç»éªŒè€Œè¨€ï¼Œæ—¥æ€å¤œæƒ³ï¼Œè±ç„¶å¼€æœ—æ˜¯å®Œå…¨æŒæ¡é€’å½’çš„å¿…ç„¶è¿‡ç¨‹ã€‚

å‡½æ•°å¼ç¼–ç¨‹ä¸­ï¼Œé€’å½’æ˜¯ä¸ªéåœ°èµ°çš„æ¦‚å¿µã€‚è¿™åœ¨ Golang ä¸­è¢«å…·ç°ä¸ºé«˜é˜¶å‡½æ•°è¿”å›å€¼ã€‚

ä¸‹é¢è¿™ä¸ªç¤ºä¾‹ç®€å•åœ°å®ç°äº†é˜¶ä¹˜è¿ç®—ï¼š

```go
package main

import "fmt"

func factorial(num int) int {
	result := 1
	for ; num > 0; num-- {
		result *= num
	}
	return result
}

func main() {
	fmt.Println(factorial(10)) // 3628800
}
```

ä½†æˆ‘ä»¬åº”è¯¥é‡‡ç”¨ Functional Programming çš„é£æ ¼é‡æ–°å®ç°å®ƒï¼š

```go
package main

import "fmt"

func factorialTailRecursive(num int) int {
	return factorial(1, num)
}

func factorial(accumulator, val int) int {
	if val == 1 {
		return accumulator
	}
	return factorial(accumulator*val, val-1)
}

func main() {
	fmt.Println(factorialTailRecursive(10)) // 3628800
}
```

å¤§å¤šæ•°ç°ä»£ç¼–ç¨‹è¯­è¨€å¯¹äºå°¾é€’å½’éƒ½èƒ½å¤Ÿå¾ˆå¥½åœ°åœ¨ç¼–è¯‘é˜¶æ®µè¿›è¡Œéšå«æ€§åœ°ä¼˜åŒ–ï¼Œè¿™æ˜¯ä¸€ä¸ªç¼–è¯‘åŸç†ä¸­çš„é‡è¦çš„ä¼˜åŒ–ç‚¹ï¼šå°¾é€’å½’æ€»æ˜¯èƒ½å¤Ÿé€€åŒ–ä¸ºæ— éœ€åµŒå¥—å‡½æ•°è°ƒç”¨çš„å¾ªç¯ç»“æ„ã€‚

æ‰€ä»¥æˆ‘ä»¬åœ¨ä¸Šé¢è¿›è¡Œäº†ä¸€å®šçš„æ”¹å†™ï¼Œä»è€Œå°†é˜¶ä¹˜è¿ç®—å®ç°ä¸ºäº† Functional çš„æ–¹å¼ï¼Œåœ¨ä»¤å…¶å…·å¤‡è‰¯å¥½çš„å¯è¯»æ€§çš„åŒæ—¶ï¼Œè¿˜èƒ½ä»¤å…¶é¿å¼€åµŒå¥—å‡½æ•°è°ƒç”¨æ—¶çš„æ ˆæ¶ˆè€—é—®é¢˜ã€‚



#### é‡‡ç”¨é«˜é˜¶å‡½æ•°çš„é€’å½’

å€Ÿç”¨ fibonacci çš„å®ç°æˆ‘ä»¬ç®€å•åœ°ç¤ºä¾‹è¿”å›ä¸€ä¸ªå‡½æ•°çš„æ–¹å¼æ¥å®ç°é€’å½’ï¼š

```go
package main

import "fmt"

func fibonacci() func() int {
	a, b := 0, 1

	return func() int {
		a, b = b, a+b
		return a
	}
}

func main() {
	f := fibonacci()

	for i := 0; i < 10; i++ {
		fmt.Println(f())
	}
}

// ä¾æ¬¡è¾“å‡ºï¼š1 1 2 3 5 8 13 21 34 55
```







### å»¶è¿Ÿè®¡ç®— Delayed Calculating

ä½¿ç”¨é«˜é˜¶/åŒ¿åå‡½æ•°çš„ä¸€ä¸ªé‡è¦ç”¨é€”æ˜¯æ•ä¿˜å˜é‡å’Œå»¶è¿Ÿè®¡ç®—ï¼Œä¹Ÿå³æ‰€è°“çš„æƒ°æ€§è®¡ç®—ï¼ˆ[Lazy evaluations](https://en.wikipedia.org/wiki/Lazy_evaluation)ï¼‰ã€‚

åœ¨ä¸‹é¢è¿™ä¸ªä¾‹å­ä¸­ï¼Œ

```go
func doSth(){
  var err error
  defer func(){
    if err != nil {
      println(err.Error())
    }
  }()
  
  // ...
  err = io.EOF
  return
}

doSth() // printed: EOF
```

åœ¨ defer çš„é«˜é˜¶å‡½æ•°ä¸­ï¼Œæ•ä¿˜äº†å¤–éƒ¨ä½œç”¨åŸŸä¸­çš„ err å˜é‡ï¼ŒdoSth çš„æ•´ä¸ªè¿è¡Œå‘¨æœŸä¸­å¯¹ err çš„è®¾å®šï¼Œæœ€ç»ˆèƒ½å¤Ÿåœ¨ defer å‡½æ•°ä½“ä¸­è¢«æ­£ç¡®è®¡ç®—å¾—åˆ°ã€‚å¦‚æœæ²¡æœ‰æ•ä¿˜å’Œå»¶è¿Ÿè®¡ç®—æœºåˆ¶çš„è¯ï¼Œé«˜é˜¶å‡½æ•°ä½“ä¸­å¯¹ err çš„è®¿é—®å°±åªä¼šå¾—åˆ° nil å€¼ï¼Œå› ä¸ºè¿™æ˜¯æ•ä¿˜æ—¶åˆ» err çš„å…·ä½“å€¼ã€‚è¯·æ³¨æ„ä¸ºäº†ç¼©å‡ç¤ºä¾‹ä»£ç è§„æ¨¡æˆ‘ä»¬é‡‡ç”¨äº† defer æ¥æ¼”ç¤ºï¼Œå®é™…ä¸Šä½¿ç”¨ go routines å¯ä»¥å¾—åˆ°åŒæ ·çš„æ•ˆæœï¼Œæ¢å¥è¯è¯´ï¼Œåœ¨é«˜é˜¶å‡½æ•°ä¸­å¯¹å¤–éƒ¨ä½œç”¨åŸŸçš„è®¿é—®æ˜¯åŠ¨æ€åœ°å»¶è¿Ÿåœ°è®¡ç®—çš„ã€‚

#### ä¾‹å¤–ï¼šå¾ªç¯å˜é‡

å½“ç„¶åœ¨è¿™é‡Œæœ‰ä¸€ä¸ªè‘—åçš„å‘ï¼šå¾ªç¯å˜é‡å¹¶ä¸è¢«å»¶è¿Ÿè®¡ç®—ï¼ˆç”±äºæ€»æ˜¯ä¼šå‘ç”Ÿå¾ªç¯è¢«ä¼˜åŒ–çš„åŠ¨ä½œï¼Œå› è€Œå¾ªç¯å˜é‡åœ¨æŸç§è§’åº¦çœ‹æ˜¯ä¸å­˜åœ¨çš„ä¼ªå˜é‡ï¼‰ã€‚

```go
func a(){
  for i:=0; i<10; i++ {
    go func(){
      println(i)
    }()
  }
}

func main(){ a() }
// 1. ç»“æœä¼šæ˜¯ å…¨éƒ¨çš„ 0
// 2. åœ¨æ–°ç‰ˆæœ¬çš„ Golang ä¸­ï¼Œå°†æ— æ³•é€šè¿‡ç¼–è¯‘ï¼ŒæŠ¥é”™ä¸ºï¼š
// loop variable i captured by func literal
```

æƒ³è¦å¾—åˆ°ç¬¦åˆç›´è§‰çš„ç»“æœï¼Œä½ éœ€è¦ä¼ å‚è¯¥å¾ªç¯å˜é‡ï¼š

```go
func a(){
  for i:=0; i<10; i++ {
    go func(ix int){
      println(ix)
    }(i)
  }
}
```

æˆ‘è€å®äº¤å¾…ï¼Œè¿™ä¸ªå‘æˆ‘è¸©è¿‡ï¼Œå•æ­¥è°ƒè¯•æ‰å‘ç°ã€‚åœ¨ä¸€ä¸ªå¤§å‹ç³»ç»Ÿä¸­ï¼Œæ‰¾åˆ°è¿™ä¹ˆä¸€ä¸ªé”™è¯¯ï¼Œä½ ä¼šå……æ»¡ç–²æƒ«æ„Ÿã€‚è€Œå®ƒæ˜¯è¡¨ç¤ºä½ çš„ç¼–ç¨‹æ°´å¹³ä¸è¡Œå—ï¼Ÿæ”¾å¿ƒï¼Œè¿™å¹¶ä¸æ˜¯ï¼Œæˆ‘ä¸æ˜¯å› ä¸ºè‡ªå·±å•ƒè¿‡æ‰æ”¾ä½æ ‡å‡†çš„ï¼Œå®åœ¨æ˜¯ Golang æœ‰å¤Ÿæ¶å¿ƒçš„ã€‚







### Functional Options

ä½œä¸ºä¸€ä¸ªç±»åº“ä½œè€…ï¼Œè¿Ÿæ—©ä¼šé¢ä¸´åˆ°æ¥å£å˜æ›´é—®é¢˜ã€‚æˆ–è€…æ˜¯å› ä¸ºå¤–éƒ¨ç¯å¢ƒå˜åŒ–ï¼Œæˆ–è€…æ˜¯å› ä¸ºåŠŸèƒ½å‡çº§è€Œæ‰©å¤§äº†å¤–å»¶ï¼Œæˆ–è€…æ˜¯å› ä¸ºéœ€è¦åºŸå¼ƒæ‰è¿‡å»çš„ä¸å®Œå–„çš„è®¾è®¡ï¼Œæˆ–è€…æ˜¯å› ä¸ºä¸ªäººæ°´å¹³çš„æå‡ï¼Œæ— è®ºå“ªä¸€ç§ç†ç”±ï¼Œä½ éƒ½å¯èƒ½ä¼šå‘ç°å¿…é¡»è¦ä¿®æ”¹æ‰åŸæœ‰çš„æ¥å£ï¼Œæ›¿æ¢ä¹‹ä»¥ä¸€ä¸ªæ›´å®Œç¾çš„æ–°æ¥å£ã€‚

#### æ—§çš„æ–¹å¼

æƒ³è±¡ä¸‹æœ‰ä¸€ä¸ªæ—©æœŸçš„ç±»åº“ï¼š

```go
package tut

func New(a int) *Holder {
  return &Holder{
    a: a,
  }
}

type Holder struct {
  a int
}
```

åæ¥ï¼Œæˆ‘ä»¬å‘ç°éœ€è¦å¢åŠ ä¸€ä¸ªå¸ƒå°”é‡ bï¼Œäºæ˜¯ä¿®æ”¹ tut åº“ä¸ºï¼š

```go
package tut

func New(a int, b bool) *Holder {
  return &Holder{
    a: a,
    b: b,
  }
}

type Holder struct {
  a int
  b bool
}
```

æ²¡è¿‡å‡ å¤©ï¼Œç°åœ¨æˆ‘ä»¬è®¤ä¸ºæœ‰å¿…è¦å¢åŠ ä¸€ä¸ªå­—ç¬¦ä¸²å˜é‡ï¼Œtut åº“ä¸å¾—ä¸è¢«ä¿®æ”¹ä¸ºï¼š

```go
package tut

func New(a int, b bool, c string) *Holder {
  return &Holder{
    a: a,
    b: b,
    c: c,
  }
}

type Holder struct {
  a int
  b bool
  c string
}
```

æƒ³è±¡ä¸€ä¸‹ï¼Œtut åº“çš„ä½¿ç”¨è€…åœ¨é¢å¯¹ä¸‰æ¬¡æ¥å£ New() çš„å‡çº§æ—¶ï¼Œä¼šæœ‰å¤šå°‘ MMP è¦æŠ›å‡ºæ¥ã€‚

å¯¹æ­¤æˆ‘ä»¬éœ€è¦ Functional Options æ¨¡å¼æ¥è§£æ•‘ä¹‹ã€‚



#### æ–°çš„æ–¹å¼

å‡è®¾ tut çš„ç¬¬ä¸€ç‰ˆæˆ‘ä»¬æ˜¯è¿™æ ·å®ç°çš„ï¼š

```go
package tut

type Opt func (holder *Holder)

func New(opts ...Opt) *Holder {
  h := &Holder{ a: -1, }
  for _, opt := range opts {
    opt(h)
  }
  return h
}

func WithA(a int) Opt {
  return func (holder *Holder) {
    holder.a = a
  }
}

type Holder struct {
  a int
}

//...
// You can:
func vv(){
  holder := tut.New(tut.WithA(1))
  // ...
}
```

åŒæ ·åœ°éœ€æ±‚å˜æ›´å‘ç”Ÿåï¼Œæˆ‘ä»¬å°† b å’Œ c å¢åŠ åˆ°ç°æœ‰ç‰ˆæœ¬ä¸Šï¼Œé‚£ä¹ˆç°åœ¨çš„ tut çœ‹èµ·æ¥æ˜¯è¿™æ ·çš„ï¼š

```go
package tut

type Opt func (holder *Holder)

func New(opts ...Opt) *Holder {
  h := &Holder{ a: -1, }
  for _, opt := range opts {
    opt(h)
  }
  return h
}

func WithA(a int) Opt {
  return func (holder *Holder) {
    holder.a = a
  }
}

func WithB(b bool) Opt {
  return func (holder *Holder) {
    holder.b = b
  }
}

func WithC(c string) Opt {
  return func (holder *Holder) {
    holder.c = c
  }
}

type Holder struct {
  a int
  b bool
  c string
}

//...
// You can:
func vv(){
  holder := tut.New(tut.WithA(1), tut.WithB(true), tut.WithC("hello"))
  // ...
}
```

ç”±äºä»£ç æ²¡æœ‰ä»€ä¹ˆå¤æ‚åº¦ï¼Œæ‰€ä»¥æˆ‘ä¸å¿…é€è¡Œè§£è¯´å®ä¾‹ä»£ç äº†ã€‚ä½ å°†ä¼šå¾—åˆ°ä¸€ä¸ªç›´è§‚çš„æ„Ÿå—æ˜¯ï¼ŒåŸæœ‰çš„ tut çš„ç”¨æˆ·ç«¯é—ç•™ä»£ç ï¼ˆä¾‹å¦‚ `vv()` ï¼‰å®é™…ä¸Šå¯ä»¥å®Œå…¨ä¸å˜ï¼Œé€æ˜åœ°åº”å¯¹ tut åº“æœ¬èº«çš„å‡çº§åŠ¨ä½œã€‚



è¿™é‡Œè¦æåˆ°è¿™ç§ç¼–ç èŒƒå¼çš„ç‰¹ç‚¹å’Œä½œç”¨åŒ…æ‹¬ï¼š

a. åœ¨å®ä¾‹åŒ– Holder æ—¶ï¼Œæˆ‘ä»¬ç°åœ¨å¯ä»¥å˜ç›¸åœ°ä½¿ç”¨ä¸åŒæ•°æ®ç±»å‹çš„ä»»æ„å¤šå¯å˜å‚æ•°äº†ã€‚

b. å€ŸåŠ©æ—¢æœ‰çš„èŒƒå¼æ¨¡å‹ï¼Œæˆ‘ä»¬è¿˜å¯ä»¥å®ç°ä»»æ„çš„å¤æ‚çš„åˆå§‹åŒ–æ“ä½œï¼Œç”¨ä»¥ä¸º Holder è¿›è¡Œä¸åŒçš„æ„å»ºæ“ä½œã€‚

c. æ—¢ç„¶æ˜¯èŒƒå¼ï¼Œé‚£ä¹ˆå…¶å¯è¯»æ€§ã€å¯æ‹“å±•æ€§éœ€è¦è¢«ç ”ç©¶â€”â€”å¾ˆæ˜æ˜¾ï¼Œç°åœ¨çš„è¿™ä¸€èŒƒå¼èƒ½å¾—åˆ°é«˜åˆ†ã€‚

d. åœ¨å¤§ç‰ˆæœ¬å‡çº§æ—¶ï¼ŒNew(...) çš„æ¥å£ç¨³å›ºæ€§ç›¸å½“å¥½ï¼Œæ— è®ºä½ å¦‚ä½•è°ƒæ•´å†…åœ¨ç®—æ³•åŠå…¶å®ç°ï¼Œå¯¹è¿™æ ·çš„ç¬¬ä¸‰æ–¹åº“çš„è°ƒç”¨è€…æ¥è¯´ï¼Œæ²¡æœ‰ä»€ä¹ˆéœ€è¦æ”¹å˜çš„ã€‚





### å°ç»“

æœ¬æ–‡å‚è€ƒäº† dcode[^7] æåˆ°çš„ä¸€äº›çŸ¥è¯†ï¼Œæ­¤å¤–ï¼Œ[7 Easy functional programming techniques in Go](https://deepu.tech/functional-programming-in-go/) [^8] ä¹Ÿä»‹ç»äº†å¾ˆå¤š FP çŸ¥è¯†ã€‚

æœ¬æ–‡æ²¡æœ‰æ‰“ç®—åœ¨ FP æ–¹é¢è¿›è¡Œå±•å¼€ï¼Œå› ä¸ºåœ¨ç¬”è€…çš„è®¤è¯†ä¸­ï¼ŒLispï¼ŒHaskell ä¹‹ç±»çš„è¯­è¨€ç¯å¢ƒä¸‹è®¨è®º FP æ‰æ˜¯æœ‰æ„ä¹‰çš„ï¼ŒGolang å½“ä¸­è™½ç„¶å¯¹ FP æœ‰å¾ˆå¤šçš„å€¾å‘ï¼Œä½†å®ƒå½“ç„¶æ˜¯è¿‡ç¨‹å¼çš„ PL ï¼Œåªæ˜¯è¯´å¯¹ FP æœ‰å¾ˆå¼ºçš„æ”¯æŒè€Œå·²ã€‚

ä½†è¿™äº›ç»†è‡´çš„çœ‹æ³•åˆ†é‡ï¼Œåªæ˜¯å­¦æœ¯ä¸Šçš„è¾¨æã€‚æ‰€ä»¥æœ¬æ–‡åªæ˜¯åœ¨å…·ä½“å®ä½œæ–¹é¢å½’çº³ä¸€äº›å…·æœ‰ç›¸å…³æ€§çš„æƒ¯ç”¨æ³•ã€‚

æˆ–è®¸ä»¥åå°±è¿™ä¸ªæ–¹é¢ä¼šå†åšå½’çº³ï¼Œä¹Ÿè®¸ä¼šæœ‰æ›´æ·±å…¥çš„è®¤è¯†ã€‚









### References



[^3]: <https://zh.wikipedia.org/wiki/%CE%9B%E6%BC%94%E7%AE%97>
[^4]: <https://en.wikipedia.org/wiki/Currying>
[^7]: <https://arschles.com/blog/functional-programming-in-go-with-dcode/>
[^8]: [7 Easy functional programming techniques in Go](https://deepu.tech/functional-programming-in-go/)







ğŸ”š